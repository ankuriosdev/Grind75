// Topic: Array, Hash Map// Difficulty: Easy// LeetCode Problem: https://leetcode.com/problems/two-sum/// Asked by: Amazon, Google, Microsoft, Facebook, Apple, Adobe    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {        // Dictionary to store value as key and index as value        var dict: [Int: Int] = [:]        // Iterate through the array to find two numbers that sum up to the target        for i in 0..<nums.count {            // Current number at index i            let num = nums[i]            // Calculate the complement that would sum with `num` to give `target`            let complement = target - num            // Check if the complement is already present in the dictionary            if let complementIndex = dict[complement] {                // If the complement exists in the dictionary, return the pair of indices                return [complementIndex, i]            }            // If the complement is not found, store the current number and its index in the dictionary            // This will help us find if this number's complement appears later in the array            dict[num] = i        }        // If no pair is found that sums up to the target, return an empty array        return []    }let nums = [2, 7, 11, 15]let target = 9let result = twoSum(nums, target) // Output will be [0, 1]print(result)// Time Complexity: O(n)// We iterate through the array of size 'n' exactly once, and for each element, we perform a constant-time lookup and insertion into the dictionary. Therefore, the overall time complexity is O(n).// Space Complexity: O(n)// In the worst case, we store every element in the dictionary. Since the dictionary stores at most 'n' elements, where 'n' is the size of the array, the space complexity is O(n).