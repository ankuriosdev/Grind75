// Topic: Valid Parentheses// Difficulty: Easy// LeetCode Problem: https://leetcode.com/problems/valid-parentheses/// Asked by: Amazon, Microsoft, Facebook// Topic: Valid Parentheses// Difficulty: Easy// LeetCode Problem: https://leetcode.com/problems/valid-parentheses/// Asked by: Amazon, Microsoft, Facebookclass Solution {    // Dictionary to map opening brackets to their corresponding closing brackets    let paranthesisCollection: [Character : Character] = ["(" : ")", "[" : "]", "{" : "}"]        func isValid(_ s: String) -> Bool {        var openers: [Character] = []                // Iterate through each character in the string        for paranthesis in s {            if isOpener(paranthesis) {                // If it's an opening bracket, add it to the stack                openers.append(paranthesis)            } else {                // If it's a closing bracket, check if the stack is empty                if openers.isEmpty {                    return false                } else {                    // Check if the current closing bracket matches the expected one                    let currentCloser = paranthesisCollection[openers.last!]                    if currentCloser == paranthesis {                        openers.removeLast()                    } else {                        return false                    }                }            }        }        // Return true if all openers were properly matched        return openers.isEmpty    }    // Helper function to check if a character is an opening bracket    func isOpener(_ s: Character) -> Bool {        return paranthesisCollection[s] != nil    }}// Time Complexity: O(n), where n is the length of the string.// We traverse the string once, and operations on the stack (push and pop) are O(1).// Space Complexity: O(n), where n is the length of the string in the worst case.// The stack can store up to n/2 opening brackets if the string is fully composed of them.class SolutionSecond {    func isValid(_ s: String) -> Bool {                // If the string length is odd, it can't be valid        guard s.count % 2 == 0 else { return false }                var stack: [Character] = []                // Iterate through the characters of the string        for ch in s {            switch ch {            case "(":                // For each opening bracket, push the corresponding closing bracket                stack.append(")")            case "[":                stack.append("]")            case "{":                stack.append("}")            default:                // For any closing bracket, check if it matches the top of the stack                if stack.isEmpty || stack.removeLast() != ch {                    return false                }            }        }                // If the stack is empty, all brackets were properly closed        return stack.isEmpty    }}// Time Complexity: O(n), where n is the length of the string.// We traverse each character once, and operations on the stack (push and pop) are O(1).// Space Complexity: O(n), where n is the length of the string in the worst case.// The stack can hold up to n/2 opening brackets if the string is fully composed of them.