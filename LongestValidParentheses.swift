// Topic: Stack// Difficulty: Hard// LeetCode Problem: https://leetcode.com/problems/longest-valid-parentheses/// Asked by: Facebook, Google, Amazon//// Topic: String Manipulation (Two-pass approach)class Solution {    func longestValidParentheses(_ s: String) -> Int {        var leftCount = 0, rightCount = 0        var maxLength = 0                // First pass: left to right        for char in s {            if char == "(" {                leftCount += 1            } else {                rightCount += 1            }                        // If we have a valid substring            if leftCount == rightCount {                maxLength = max(maxLength, 2 * rightCount)            } else if rightCount > leftCount {                // Reset counters if too many right parentheses                leftCount = 0                rightCount = 0            }        }                // Reset counters for the second pass        leftCount = 0        rightCount = 0                // Second pass: right to left        for char in s.reversed() {            if char == ")" {                leftCount += 1            } else {                rightCount += 1            }                        // If we have a valid substring            if leftCount == rightCount {                maxLength = max(maxLength, 2 * rightCount)            } else if rightCount > leftCount {                // Reset counters if too many left parentheses                leftCount = 0                rightCount = 0            }        }                return maxLength    }}// Time Complexity: O(n) where n is the length of the input string.// Space Complexity: O(1) since we are only using counters.// Stack based approachclass Solution {    func longestValidParentheses(_ s: String) -> Int {        // Stack to store indices of unmatched parentheses        var stack: [Int] = []        // Initial condition: push -1 to the stack to help calculate valid lengths        stack.append(-1)        var maxLength = 0                for (i, char) in s.enumerated() {            if char == "(" {                // Push the index of the '(' onto the stack                stack.append(i)            } else {                // Pop the top of the stack since we found a matching ')'                stack.popLast()                                // If the stack is not empty, calculate the valid length                if let lastIndex = stack.last {                    maxLength = max(maxLength, i - lastIndex)                } else {                    // If the stack is empty, push the current index                    // This index will serve as the base for future valid substrings                    stack.append(i)                }            }        }                return maxLength    }}// Time Complexity: O(n) where n is the length of the input string.// Space Complexity: O(n) due to the stack storing indices.